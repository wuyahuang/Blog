# 为什么 0.1 + 0.2 != 0.3 ?


在数学上我们总有办法通过额外的符号表示更复杂的数字，但是从工程的角度来看，表示无限精度的数字是不经济的，我们期望通过更小和更快的系统表示范围更大和精度更高的实数。浮点数系统是在工程上面做的权衡，IEEE 754 就是在 1985 年建立的浮点数计算标准，它定义了浮点数的算术格式、交换格式、舍入规则、操作和异常处理5。


基于 IEEE 754 标准，Javascript 的 Number 设定为 64 位的双精度浮点数。

双精度浮点数 double 总共包含 64 位，其中 1 位表示符号，11 位表示指数，最后 52 位表示小数；

<img src="../assets/floating-point.png" alt="avatar" width="50%" height="50%">


我们日常生活中使用的数字基本都是 10 进制的，然而计算机使用二进制的 0 和 1 表示整数和小数，所有有限的十进制整数都可以无损的转换成有限长度的二进制数字，但是要在二进制的计算机中表示十进制的小数相对就很麻烦了，我们以 0.375 为例介绍它在二进制下的表示：

```
(0.375)10=(0.011)2
```

小数点后面的位数依次表示十进制中的 0.5、0.25、0.125 和 0.0625 等等，这个表示方法非常好理解，每一位都是前一位的一半。0.375 在二进制表示看来确实是『整数』。然而如下所示，想要使用二进制表示十进制中的 0.1 和 0.2 是比较复杂的:

```
0.1 -> 0.00011001100......
0.2 -> 0.0011001100......
```

无论是 0.1 还是 0.2，这两个数字都不是二进制中的『整数』，我们没有办法精确地表示它们，只能通过无限循环小数尝试接近它们的真实值；与之相似的是，它们相加的结果 0.3 也无法用有限长度的二进制表示：

```
0.3 -> 0.010011001100...
```

这三个不同的数字都会在最后的小数部分无限循环 1100 来趋近于真实值，如果计算机中的浮点数可以表示无限循环小数就有可能解决这个问题，但是事实的真相是浮点数只会表示有限小数，所有超过特定精度的数字都会做舍入处理。

因此，0.1 + 0.2，在 Javascript 中会返回:

```
0.30000000000000004
```


参考资料：

[为什么 0.1 + 0.2 = 0.300000004](https://draveness.me/whys-the-design-floating-point-arithmetic/)